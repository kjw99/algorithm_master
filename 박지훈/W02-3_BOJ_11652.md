## boj 11652번 문제
https://www.acmicpc.net/problem/11652

```
import sys
from collections import Counter

# 몇개의 숫자를 인풋 받는가?
number_of_numbers = int(sys.stdin.readline())
lst = []
i = 0

# 인풋받는 갯수 만큼 for문을 통해 리스트에 append
for i in range(number_of_numbers):
    number = int(sys.stdin.readline())
    lst.append(number)

# 작은 숫자로 정렬
new_lst = sorted(lst)

# counter를 사용해서 빈도수 계산
count_num = Counter(new_lst)

# 빈도수가 가장 높은 숫자 찾기
max_num = count_num.most_common(n=1)

print(max_num[0][0])
```

### 문제점
진짜 아무리 봐도 잘못만든 코드
그런데 정답이긴 함

문제는 빈도수를 찾고 가장 빈도수가 높은 수를 찾고 빈도수가 가장 높은 수가 다수라면 그 수들 중 가장 작은 값을 찾는 문제
내 생각으로는 가장 빈도수가 높은 수가 다수라면 그 수들을 비교 후 찾는 문제 같은데
이 코드는 일단 작은 수로 정렬하면 되겠지 싶어서 해봤는데 된 그런 느낌
뭔가 문제의 허점을 통한 정답인 느낌

## AI(제미나이)가 생각한 최적의 코드
```
import sys

# 1. 입력을 더 빠르게 처리 (sys.stdin.read().split()으로 한 번에 읽기)
def solve():
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    
    n = int(input_data[0])
    cards = input_data[1:]
    
    # 2. Dictionary를 사용하여 빈도수 계산 (Counter의 원리지만 더 직관적)
    # 정렬되지 않은 상태에서 빈도를 세는 것이 가장 빠릅니다.
    counts = {}
    for card in cards:
        card = int(card)
        counts[card] = counts.get(card, 0) + 1
    
    # 3. 최적의 값 찾기 (정렬 대신 한 번의 루프로 해결)
    # 메모리와 시간을 가장 많이 잡아먹는 '전체 정렬'을 피합니다.
    max_count = -1
    answer = 0
    
    # Dictionary의 키들을 정렬 (작은 수부터 확인하기 위함)
    for card in sorted(counts.keys()):
        if counts[card] > max_count:
            max_count = counts[card]
            answer = card
            
    print(answer)

solve()
```

### 실제 비교
AI의 코드가 메모리는 약간 더 먹었으나 문제 해결 시간이 30ms 단축됨