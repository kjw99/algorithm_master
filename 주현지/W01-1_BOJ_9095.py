# https://www.acmicpc.net/problem/9095
# 9095 1, 2, 3 더하기
# 알고리즘: 다이나믹 프로그래밍 (DP)
# 핵심: n을 만드는 방식을 이전단계의 값으로 표현 (점화식)


"""
[1] DP를 선택한 이유
- '방법의 수', '최댓값', '최솟값'을 구하는 문제
- 완전 탐색(재귀)으로 풀면 중복 계산이 너무 많아 시간이 오래 걸릴 때

핵심 원리: "기억하며 풀기" (이미 계산한 작은 문제의 답을 메모리에 저장하고 재사용)

[2] DP 접근 4단계 
1. DP 문제인지 확인
큰 문제를 작은 문제로 쪼갤 수 있는가?
작은 문제의 답이 큰 문제에서도 동일하게 쓰이는가?
2. 상태 정의
dp[n]이 무엇을 의미하는지 정의 (예: dp[n]은 숫자 $n$을 만드는 방법의 수).
3. 점화식 세우기 (Relation)현재 단계(n)와 이전 단계(n-1, n-2...)의 관계 찾기.
예: $dp[n] = dp[n-1] + dp[n-2] + dp[n-3]$
4. 기초값(Base Case) 설정더 이상 쪼개지지 않는 가장 작은 문제의 답 정하기 (예: dp[1]=1).
"""

'''
<1>
1
<2>
11 2
<3>
111 21 / 12 3
<4>
1111 211 121 31 / 112 22 / 13
<5>
11111 2111 1211 311 1121 221 131 / 1112 212 122 32 / 113 23

dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
'''

import sys
input = sys.stdin.readline

# 초기값 설정
dp = [0] * 12
dp[1] = 1
dp[2] = 2
dp[3] = 4

# n이 최대 11로 작아서 미리 계산해둠
for i in range(4, 11):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

t = int(input())
for _ in range(t):
    n = int(input())
    print(dp[n])
