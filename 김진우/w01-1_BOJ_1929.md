## 문제 주소
* https://www.acmicpc.net/problem/1929

## 문제 설명
* M, N이 주어질 때, M이상, N이하의 소수를 모두 출력하는 프로그램을 작성하기. (1 <= M <= N <= 1,000,000)

## 배운 점!
* "에라토스테네스의 체" 라는 소수를 찾는 방법이 있다.
* 임의의 자연수 n이하의 소수를 찾는, 가장 간단하고 빠른 방법이라고 함.

## 에라토스테네스의 체 간단 설명
1. 1 ~ 144의 숫자가 있다.
2. 일단 1은 소수가 아니니까 제거.
3. 2를 제외한 2의 배수를 제거.
4. 3을 제외한 3의 배수를 제거.
5. 다음 번호인 4는 이미 2의 배수라서 제거됨! 5를 제외한 5의 배수를 제거.
6. 이런 과정을 계속 반복. 144 이상의 숫자는 범위 밖의 숫자니까 계산하지 말자.
7. 이러면 남아있는 숫자들이 소수가 된다.


## 로직

1. 입력 값을 받아서 M, N에 저장.
2. 소수를 나타내는 boolean형의 check 리스트를 생성하고 N + 1 크기만큼 True로 초기화.
3. <B>(중요!)</B> check[1]은 숫자 1을 나타낸다. 1은 소수가 아니니까 False로 저장.
4. 반복문 시작. 반복 조건은 2 ~ N의 제곱근 + 1 만큼.
    * math.sqrt(N)은 N의 제곱근을 반환하는 함수. 144 -> 12
    * int()함수를 통해 11.1234 이런식의 값이 나오면 11로 만드는 것!
    * 왜 조건이 2 ~ N + 1이 아닐까?
    * i가 13 이라고 가정해보자, 앞에서 이미 2 ~ 12를 거쳐오는 동안 각 숫자의 배수가 제외되었을 것이다.
    * 13 26 39 52 65 78 91 104 117 130 143 ...
    * 169은 13 * 13이다. 169 이전의 숫자들은 전부 i가 13이 되기 전에 제외된 숫자들임.
    * 즉, i가 13이라면 제외되는 숫자는 169 이후의 숫자들이 된다.
    * 근데 문제에서 N의 값이 144 라면? i가 13인 경우를 굳이 계산하지 않아도 된다.
    * 그래서 반복문의 조건을 2 ~ 12(144의 제곱근) + 1 로 지정해서 i의 값이 2 ~ 12인 경우만 계산하도록 한 것!
5. check[i]의 값이 False 라는 것은, 이미 소수 체크에서 제외된 숫자라는 뜻. 다음 반복으로 넘어간다.
6. 반복문을 한번 더 사용. 이번에는 2 ~ N + 1까지 반복을 조건으로 하지만, i * j 값이 N보다 크면 반복 종료.
7. num에 i * j를 저장하고, N보다 작으면 check[num]의 값을 False로 변경.
    * 이 과정을 통해 2의 배수, 3의 배수 등 소수가 아닌 숫자를 다 제외하게 된다.
8. 2중 반복문 다 끝나면 M ~ N + 1까지 반복하면서 check의 값이 True 숫자만 출력.

## 코드

```python
# https://www.acmicpc.net/problem/1929
import math

# 입력값 받기.
M, N = map(int, input().split())

# 소수 체크용 리스트. True = 소수다.
check = [True for i in range(N + 1)]
check[1] = False

# 2중 반복문.
# i를 제외한 i의 배수를 False 처리하는 로직.
for i in range(2, int(math.sqrt(N)) + 1):
    if check[i] == False:
        continue
    for j in range(2, N + 1):
        num = i * j
        if num > N:
            break
        check[num] = False

# 출력
for i in range(M, N + 1):
    if check[i]:
        print(i)


```
