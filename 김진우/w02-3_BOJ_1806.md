## 문제 주소
* https://www.acmicpc.net/problem/1806

## 문제 설명
* 10000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다.
* 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하시오.
* 5 1 3 5 10 7 4 9 2 8 << 이런 형태의 수열이 있고, S의 값이 15라고 가정하면, 15이상이 될 수 있는 부분합은 (5, 1, 3, 5, 10), (1, 3, 5, 10), (5, 10), (10, 7), (4, 9, 2) 등.. 다양하게 있음.
* 해당 부분합 중 가장 길이가 짧은 것을 구하는 문제.

## 문제를 풀며 생각할 점
* 연속된 수들의 부분합이니까 서로 붙어있는 숫자의 합으로 계산해야 한다.
* 수열의 최대 길이가 길어서 sum(lst[0:5]), sum(lst[1:5])... 이런식으로 하나 하나 새롭게 연산하기 보다는 기존의 연산 결과를 활용하도록 구현하자.

## 로직
1. 부분합 중에서 가장 짧은 길이의 부분합을 찾기 위해서는 { 1번 ~ 1번의 합, 1번 ~ 2번의 합 ... 2번부터 n번의 합 ... n번 부터 n번의 합 } 이런 식으로 모든 조합을 다 확인해봐야 한다.
2. 위의 예시를 통해 설명하자면, (5) -> (5, 1) -> (5, 1, 3) 이런식으로 값을 더하고 목표와 비교하게 되는데, 중복되는 연산이 생긴다.
3. 단순하게 sum(lst[i:j]) 이런식으로 하게 되면 연산을 너무 많이 반복해서 시간 초과가 나옴!
4. 그래서 중복되는 연산은 하지 않고, 새로 필요한 연산만 수행할 수 있도록 구현함.
5. 이를 위해 start, end 변수를 추가. 부분합이 (5, 1, 3, 5, 10) 이런 형태라면, start가 맨 왼쪽의 5를 가리키도록, end는 맨 오른쪽의 10을 가리키도록 인덱스를 저장해서 관리.
6. 처음에는 [0]의 값부터 시작해서 목표 값 이상이 될 때까지 계속 합하다가 (이 과정에서 end의 값도 계속 +1이 된다.), 목표 값 이상이 되면, 몇 개의 수를 더했는지 기록하고, 누적 합에서 [0] 번째 값을 뺀다.
7. 이번에는 [0]부터 시작해서 누적 합에서 값을 빼주면서 누적 값이 목표 값 미만이 될 때까지 반복. (이 과정에서는 start 값이 +1 됨.)
8. 누적 값이 목표 값 미만이 되면, 다시 6번 과정부터 반복.
9. 계산이 끝나면, 조건문을 통해 초기값 체크하고, 초기값에서 변경이 없으면 0을 출력.

## 코드

```python
# https://www.acmicpc.net/problem/1806
import sys

input = sys.stdin.readline

number_len, number_target = map(int, input().split())
number_list = list(map(int, input().split()))

# 누적합 계산 함수
def subtotal():    
    min_len = float('inf')
    
    # [start : end] 느낌으로 생각하자.
    start = 0
    end = 1
    # start ~ end번째 수를 합한 값
    # 첫 번째 수부터 넣고 반복문 시작.
    hap = number_list[0]
    while end <= number_len:
        # 합이 요구하는 수 이상인 경우
        if hap >= number_target:
            # 몇 개의 값을 합했는지 체크.
            length = end - start
            # 숫자 1개로 요구하는 숫자 이상인 경우 바로 계산 끝.
            if length == 1:
                return 1
            # hap의 구성 요소 중 맨 왼쪽에 위치한 값을 빼준다.
            hap -= number_list[start]
            # 맨 왼쪽의 위치 값을 변경. 한 칸 오른쪽으로.
            start += 1
            # 더 적은 개수로 갱신 가능한 경우 갱신.
            if length < min_len:
                min_len = length
        # 합이 nuber_len 미만인 경우.
        else:
            if end < number_len:
                # hap을 구성하는 범위 증가.
                # 오른쪽 한칸 증가. 오른쪽에 있는 값 더하기.
                hap += number_list[end]
            # 맨 오른쪽의 위치 값 변경.
            end += 1
    
    return min_len

result = subtotal()
# 계산 결과가 초기값 그대로면 계산 불가. 값을 0으로 변경
if result == float('inf'):
    result = 0
print(result)



```
