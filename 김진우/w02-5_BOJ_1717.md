## 문제 주소
* https://www.acmicpc.net/problem/1717

## 문제 설명
* n + 1개의 집합이 주어진다. 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지 확인하는 연산을 수행하는 프로그램을 작성하자.
* 유니온-파인드(union-find) 자료구조를 사용하는 문제.
* 집합의 묶음을 관리하는 자료구조인데, 여기서 말하는 집합은 서로소 집합이라고 한다.
* 서로소 집합은 하나의 원소가 둘 이상의 집합에 속하지 않는다.
* 이 집합을 가진 자료구조에 대해 union 연산을 하면 두 집합을 합치는 연산, find 연산은 주어진 원소가 포함된 집합의 부모(루트) 노드를 구하는 연산.
* 문제에서 요구하는 대로 union 연산, find 연산을 구현해서 입력 값에 맞춰서 사용해주면 된다.

## 문제를 풀며 생각할 점
* python에서 재귀 함수를 너무 깊게 실행하면 런타임 에러가 나온다. 근데 이번 문제의 테스트 케이스 중에 기본 설정된 재귀의 최대 깊이보다 더 많이 재귀 함수를 요구하는 경우가 있어서 임의로 재귀의 최대 깊이를 설정해줘야 한다.
* sys.setrecursionlimit(10**5) 해당 코드를 통해 해결 가능.

## 로직
1. find, union 함수 생성.
2. 주어진 입력값을 통해 find, union 함수 실행하고 결과 출력.

## 코드

```python
# https://www.acmicpc.net/problem/1717
import sys
# python에서 재귀의 최대 깊이를 설정하는 코드. 해당 코드가 없으면 에러가 나는 테스트 케이스가 있음.
sys.setrecursionlimit(10**5)

# 각 트리셋의 자식 노드가 루트(최상위 노드)를 찾는 함수 
def find(node_list, x):
    
    if node_list[x] == x:
        return x
    node_list[x] = find(node_list, node_list[x])
    return node_list[x]

# 한 트리셋의 루트가 다른 트리셋의 루트를 가리키게 하여 트리를 병합하는 함수
def union(x, y):
    nx = find(node_list, x)
    ny = find(node_list, y)
    if nx != ny:
        node_list[nx] = ny

input = sys.stdin.readline

num, operation = map(int, input().split())

node_list = []
result = []

# n + 1개의 트리 생성. 0번 트리는 0이 루트노드 1번 트리는 1이 루트.. 이런 식으로.
for i in range(0, num + 1):
    node_list.append(i)

for _ in range(operation):
    oper, node1, node2 = map(int, input().split())
    if oper == 0:
        # node1번 트리와 node2번 트리를 병합.
        union(node1, node2)
    else:
        # 1, 2번의 루트 노드를 찾고 비교.
        value1 = find(node_list, node1)
        value2 = find(node_list, node2)
        # 루트 노드가 같다 = 같은 집합
        if value1 == value2:
            result.append("YES")
        else:
            result.append("NO")        

sys.stdout.write("\n".join(map(str, result)))




```
