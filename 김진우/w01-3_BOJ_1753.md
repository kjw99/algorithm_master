## 문제 주소
* https://www.acmicpc.net/problem/1753

## 문제 설명
* 방향 그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하라.
* 다익스트라 알고리즘을 쓰라는 뜻!

## 배운 점!
* python에서 다익스트라 알고리즘 구현을 위해 heapq, defaultdict를 사용해보자.

## heapq
* heapq는 항상 작은 값이 0번 인덱스에 위치함. 최소 힙 구조다.
* 기존의 리스트 형태로 사용하되, heapq.heappush(), heapq.heappop() 등을 사용.

## defaultdict
* defaultdict는 키가 없어도 에러가 안 나게 해주는 딕셔너리 라고 함.
* 초기값을 자동으로 만들어주는 dic.
* counts = defaultdict(int) 이렇게 쓰면 기본값 0으로 설정. counts["a"] += 1 를 하면 {"a" : 1} 이런식으로 값이 넣어짐.
* 기본 dic 쓰면 += 연산을 바로 못함.
* groups = defaultdict(list) 이렇게 리스트를 지정한 경우에는 빈 리스트가 초기값이 된다.
* 마찬가지로 groups["apple"].append(1)를 하는 경우 {'apple' : [1]} 이렇게 데이터가 생성됨. (원래는 append() 이전에 키 : 값으로 생성부터 해줘야 함.)

## 다익스트라 알고리즘
* 다익스트라 알고리즘은 그래프에서 최단 경로를 구하는 알고리즘이다.
* 시작점이 주어지면, 그 시작점에서 도달 가능한 모든 정점에 대한 최단 경로를 탐색한다.
* 하나의 정점에서 출발하는 최단 경로를 구하기 때문에 시작점이 필요하다.
* 각 간선마다 가중치가 주어져 있을 때 사용하자. 단, 음수 가중치는 안됨.(음수는 벨만포드)
* 자료 구조 그래프에 대해 알고 배우는 게 좋을 듯?
* 공부에 참고한 링크 : https://velog.io/@suk13574/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Java%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BCDijkstra-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

## 로직
1. 주어진 입력값 각 변수에 저장.
2. 입력값을 사용해 다익스트라 알고리즘 실행.
3. 문제의 조건을 보며 결과 출력.

## 코드

```python
# https://www.acmicpc.net/problem/1753
from collections import defaultdict
import heapq
import sys

# graph는 [정점A](정점B까지의 거리, 정점B) 형태로 되어있는 리스트.
# graph[4](10, 1)
def dijkstra(start, n, graph):
    # dist 리스트 = 시작점에서 각 종점들까지의 최단 경로를 저장하는 리스트. 초기값은 max값으로 초기화.
    dist = [float('inf')] * (n + 1)

    # dist[start] = 시작점에서 시작점까지의 거리 = 0
    dist[start] = 0

    # pq = Priority Queue. 우선순위 큐에 시작 정점 추가. (거리, 정점번호) 형태
    pq = [(0, start)]

    # while 반복문. pq에 값이 없어질 때까지 반복
    while pq:        
        # heappop()을 통해 pq에 있는 값들 중 거리가 가장 작은 값을 빼서 cost, now에 저장
        cost, now = heapq.heappop(pq)

        # cost는 now 정점에 올 때까지 누적된 거리
        # dist[now]는 현재 저장되어 있는 now 정점까지 가는 최단 경로
        # 두 값을 비교해서 cost가 더 크면 dist 값 갱신을 안해도 되니까 다음 반복으로 넘어감.
        if cost > dist[now]:
            continue
        
        # graph[now] = now에서 이동 가능한 정점과 거리가 담겨있음. (가중치, 정점번호)
        # 반복문을 통해 now 정점에서 이동 가능한 다른 정점들의 거리와 정점번호를 가져옴.
        for weight, nxt in graph[now]:

            # 위에서 뽑아낸 cost 값과 다음 정점 까지의 거리를 합해서 new_cost로 저장.
            new_cost = weight + cost

            # dist[nxt] = 현재 기록된 nxt번 정점의 최단 경로 거리.
            # new_cost가 기록된 최단 경로보다 작다면, 새롭게 갱신하고 pq에 삽입.
            if new_cost < dist[nxt]:
                dist[nxt] = new_cost
                heapq.heappush(pq, (new_cost, nxt))

    return dist

input = sys.stdin.readline
graph = defaultdict(list)

vertex_num, edge_num = map(int, input().split())
start = int(input())

# 간선 개수만큼 반복. graph에 간선에 대한 정보 저장.
for _ in range(edge_num):
    # left 정점 -> right 정점으로 이동하는데 weight(거리값) 만큼 이동해야 한다.
    left_vertex, right_vertex, weight = map(int, input().split())
    graph[left_vertex].append((weight, right_vertex))

dist = dijkstra(start, vertex_num, graph)
result = []

for i in dist[1:]:
    if i == float('inf'):
        result.append("INF")
    else:
        result.append(i)

sys.stdout.write("\n".join(map(str, result)))

```
