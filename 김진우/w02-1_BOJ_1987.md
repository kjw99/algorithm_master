## 문제 주소
* https://www.acmicpc.net/problem/1987

## 문제 설명
* 세로R, 가로C 칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸(1행 1열)에는 말이 놓여 있다.
* 말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.
* 좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.

## 문제를 풀며 생각할 점
* dfs 알고리즘을 사용했는데, 방문 체크에서 주의할 부분이 있다.
* 하나의 경로 끝까지 이동 한후 돌아와서 다른 경로로 이동하는 경우를 고려해서 방문 체크를 고려해야 함. A - B - C 까지 갔다가, A로 돌아와서 A - D - B - C 이런 식으로 이동할 수도 있으니까, 돌아간 경우에는 방문 체크를 다시 해줘야 한다. (지나갈 때 True, 돌아올 때 False)
* 알파벳으로 이루어진 데이터니까 따로 알파벳의 개수인 26길이의 boolean 리스트로 방문 체크를 해도 되고, set을 사용해서 방문 체크를 해도 좋다.
* 백준에서 python으로 제출하면 안되는데, pypy3로 제출하면 통과됨! 로직을 좀 더 손보면 python으로도 가능하긴 할 듯?
* python에서 local 변수와 global 변수가 있는데, 보통 함수 바깥에 선언한 변수를 함수 내부에서 사용하는 것은 가능하지만, 함수 내부에서 값을 변경하려고 하면 안됨! 
* 함수 바깥에서 선언된 변수를 값을 바꾸면서 다루고 싶으면 함수 내부에서 global (사용할 변수) 이런식으로 "나는 함수 내부에서 global 변수를 사용할 거야."라고 선언해줄 필요가 있다.

## 로직
1. 표의 크기인 width, height를 받고, 표의 데이터를 다 받아서 채워준다.
2. dfs에서 사용할 dr, dc 리스트, 값을 저장할 max_move, 방문 체크할 visited set을 선언.
3. dfs 함수 생성.
4. dfs에서 global 변수인 max_move를 사용하기 위해 global 키워드 사용.
5. 함수 시작 부분에서 if를 통해 max_move 값 갱신하도록 구현
6. 표에서 상, 하, 좌, 우로 이동하니까 반복문 4번 진행.
7. 위에서 만든 dr, dc 리스트는 반복문에서 사용하기 위한 리스트.
8. 기존의 좌표가 col, row이고, 반복문의 첫번째 반복에서는 col + dc[0], row + dr[0] 이런식으로 값이 들어가게 될 것임.
9. dc[0] = -1, dr[0] = 0 이니까, 계산해보면 현재 좌표에서 한칸 위의 좌표를 가리키게 된다.
10. 이런식으로 반복문을 통해 상, 하, 좌, 우의 좌표를 순서대로 계산하기 위해 dr, dc 리스트를 만들었다. 굳이 row, col 분리 안하고 drc = [(-1, 0), ...] 이런 느낌으로 만들어서 써도 된다.
11. 반복문 안에는 if문을 통해 표의 바깥 범위로 넘어가는 계산은 continue를 통해 패스한다.
12. cur_text 변수에 이동한 좌표의 알파벳을 저장. 해당 알파벳이 visited 안에 있는지 확인.
13. 있으면 계산 안하고 넘어가고, 없으면 cur_text를 visited에 추가 후 dfs 함수를 재귀 호출!
14. 재귀 호출 아래에 넣었던 cur_text를 다시 뺀다. discard()는 set 안에 있는 데이터를 빼내는 기능.
15. 이제 잘 만든 dfs 함수를 실행하고 max_move를 출력하면 끝.

## 코드

```python
# https://www.acmicpc.net/problem/1987
import sys

input = sys.stdin.readline
height, width = map(int, input().split())
# 문제에서 주어진 표를 담기 위한 리스트.
text_list = []
# 상, 하, 좌, 우 이동 계산에 사용할 리스트
dc = [-1, 1, 0, 0]
dr = [0, 0, -1, 1]
# 최대 이동 거리
max_move = 0
# 이동하면서 지나간 알파벳을 모아놓기 위한 변수.
visited = set()

# dfs를 계산하기 위한 col, row 위치와 이동 거리 move를 매개 변수로 받는다.
def dfs(col, row, move):
    # global 변수 max_move를 사용하기 위한 선언.
    global max_move
    if max_move < move:
        max_move = move

    # 상, 하, 좌, 우 이동을 위한 반복문.
    for i in range(4):
        nc = col + dc[i]
        nr = row + dr[i]

        # 표의 범위 바깥으로 이동하면 계산 X
        if nr < 0 or nc < 0 or nr >= width or nc >= height:
            continue
        
        # 이미 지나간 알파벳이면 계산 X
        cur_text = text_list[nc][nr]
        if cur_text in visited:
            continue
        
        # 이동한 알파벳 추가. 새로운 좌표와 move 값을 사용해 dfs 재귀 호출.
        visited.add(cur_text)
        dfs(nc, nr, move + 1)
        # 위의 재귀 호출이 끝나면 다시 이동한 알파벳 제거.
        visited.discard(cur_text)

for _ in range(height):
    text = input()
    text_list.append(text)

# 시작 위치는 항상 0, 0
visited.add(text_list[0][0])
dfs(0, 0, 1)
print(max_move)


```
