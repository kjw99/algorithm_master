## 문제 주소
* https://www.acmicpc.net/problem/13549

## 문제 설명
* 수빈이와 동생이 숨바꼭질을 한다. 점의 범위는 0 ~ 100000이고, 수빈과 동생은 각자 특정 점에 위치함.
* 수빈이는 1의 시간을 소모해서 앞 또는 뒤로 한 칸 이동 가능.
* 수빈이는 시간 소모 없이 본인 위치 * 2의 점으로 이동 가능.
* 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초인지 구하자.

## 문제를 풀며 생각할 점
* 각 정점으로 이동하는 방법이 다양하니까 전부 실행해보면서 최소 시간을 찾는다.
* 각 정점으로 도착하는 최소 시간을 전부 저장.
* 이후 같은 정점을 계산할 때는 저장된 최소 시간보다 짧은 경우에만 계산하도록 구현.
* +1, -1, * 2의 연산이 있는데, 연산할 때 정점의 범위인 0 ~ 100000을 벗어나지 않도록 주의.
* 각 정점에 따라 최소 시간을 저장하고 3가지 연산을 반복해서 모든 정점에 도달하는 최소 시간을 구해보자.

## 로직
1. 주어진 입력값 각 변수에 저장.
2. 입력값을 사용해 다익스트라 알고리즘 실행.
3. 문제의 조건을 보며 결과 출력.

## 코드

```python
# https://www.acmicpc.net/problem/13549
import heapq
import sys

# 술래잡기 시작
# 다익스트라 알고리즘 활용
def play_tag(N, K):
    # N = 수빈, K = 동생
    # 이동 방법이 한 칸 앞으로, 뒤로, x2로 이동 3가지.
    # 수빈이 동생보다 앞(오른쪽)에 있으면 뒤로 이동하는 방법밖에 없음.
    if N > K:
        return N - K
    # 둘의 위치가 같으면 바로 끝!
    elif N == K:
        return 0
    # 0 ~ 100000까지니까 해당 크기만큼 최대값으로 초기화.
    # dist는 각 정점에 방문한 최소 시간을 저장할 것임.
    dist = [float('inf')] * (100001)
    # 술래의 시작 지점은 당연히 0.
    dist[N] = 0

    # 우선순위 큐에 시작점을 넣고 계산 시작.
    pq = [(0, N)]
    while pq:
        cost, now = heapq.heappop(pq)

        # 저장된 최소 시간보다 pq에서 뽑은 최소 시간이 더 길면 굳이 계산 안해도 됨.
        # 우리 목적은 K에 도달하는 최소 시간 구하기. 저장되어 있는 K의 최소 시간보다 cost가 커도 계산 안해도 됨.
        if cost > dist[now] or cost >= dist[K]:
            continue
        # now가 K보다 크거나 같다 = 술래가 동생보다 앞에 있다. 앞에 있으면, -1만 가능하니까 바로 계산 가능.        
        if now >= K:            
            new_cost = cost + now - K
            # 최소 시간 갱신 가능하면 갱신하기.
            if dist[K] > new_cost:
                dist[K] = new_cost
        else:
            # now가 0이면 *2 하는 의미가 없다. now * 2가 최대 길이인 10만보다 크면 계산 안해도 됨!
            if now != 0 and now * 2 <= 100000:
                # dist[now * 2] = 저장되어 있는 now * 2 위치까치 가는 최소 시간.
                if cost < dist[now * 2]:
                    # pq에 시간, 정점번호 저장하고 dist에 갱신.
                    heapq.heappush(pq, (cost, now * 2))
                    dist[now * 2] = cost

            # 앞, 또는 뒤로 가기 위해선 +1의 시간이 필요. 계산을 위해 new_cost에 cost + 1로 저장.
            new_cost = cost + 1
            # 앞 정점에 최소 시간 갱신이 가능하면 실행
            if new_cost < dist[now + 1]:
                heapq.heappush(pq, (new_cost, now + 1))
                dist[now + 1] = new_cost

            # 음수 번호 정점은 없음! 최소 0이니까 음수로 가면 계산 X
            if now - 1 >= 0:
                if new_cost < dist[now - 1]:
                    heapq.heappush(pq, (new_cost, now - 1))
                    dist[now - 1] = new_cost
    
    return dist[K]

input = sys.stdin.readline

N, K = map(int, input().split())

result = 0
result = play_tag(N, K)

print(result)

```
