## 문제 주소
* https://www.acmicpc.net/problem/2493

## 문제 설명
* 탑의 개수와 탑의 높이를 입력 값으로 준다.
* 각 탑의 꼭대기에서 왼쪽 방향으로 레이저 신호를 수평으로 발사한다.
* 탑에서 발사한 레이저가 다른 탑에 맞아서 수신될 수 있다면, 수신 받은 탑의 번호들을 구하라.
* 수신 받은 탑이 없으면 0을 출력.

## 로직
1. 레이저의 방향이 왼쪽으로 가니까, 오른쪽부터 계산해보자.
2. 레이저가 수신되지 못한 탑은 스택에 push.
3. 반복문을 통해 왼쪽으로 하나 하나 이동하며 스택의 가장 위에 있는 탑과 현재 탑의 높이를 비교.
4. 레이저 수신이 가능한 경우 스택에서 pop 하고, 다시 가장 위에 있는 탑과 현재 탑을 계산하는 것을 반복.
5. 레이저 수신이 불가능해서 스택에 push 된 경우 while문을 탈출하고 왼쪽 탑으로 이동.
6. 수신 된 탑은 results 리스트에 수신한 탑의 번호를 저장.

## 코드

```python
# https://www.acmicpc.net/problem/2493
import sys

input = sys.stdin.readline
# 탑의 개수, 탑의 높이 리스트, 정답 리스트
top_num = int(input())
top_list = list(map(int, input().split()))
results = [0 for _ in range(top_num)]

# 탑의 오른쪽 부터 확인해서 왼쪽으로 진행.
# 아직 본인의 레이저 신호를 수신 받은 탑이 없는 탑을 모아놓은 stack
stack = []
# 맨 처음엔 가장 오른쪽의 탑을 저장. (탑의 index, 탑의 높이) 형태의 데이터
stack.append((top_num - 1, top_list[top_num - 1]))

# 반복문. 오른쪽 -> 왼쪽 이니까 n-1번탑 부터 시작.
for i in range(top_num - 2, -1, -1):
    while True:

        # 스택의 길이가 0보다 크다 = 스택에 계산할 탑이 남아 있다.
        # top_list[i] = i위치에 있는 탑의 높이
        # stack[-1][1] = 스택의 가장 위에 있는 탑의 높이
        # stack의 탑이 보내는 레이저 신호를 수신할 수 있다면 results에 기록
        if len(stack) > 0 and top_list[i] >= stack[-1][1]:
            # 신호 수신 받은 탑은 stack에서 제외.
            index, top_height = stack.pop()
            # index는 results에 저장하기 위한 리스트의 인덱스.
            # 실제 값은 1번탑, 2번탑 이런식으로 보여줘야 함.
            # 그래서 i + 1을 저장.
            results[index] = i + 1
        # 현재 탑의 높이가 stack의 탑보다 작다면 스택에 저장.
        else:
            stack.append((i, top_list[i]))
            break
# 리스트 출력할 때 앞에 *를 붙이면 1 2 3 4 << 이런 식으로 출력함.
print(*results)


```
