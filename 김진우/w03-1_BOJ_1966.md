## 문제 주소
* https://www.acmicpc.net/problem/1966

## 문제 설명
* 프린터 기기는 인쇄 명령을 받은 순서대로 인쇄를 진행함. 인쇄 대기중인 문서들이 각각 중요도가 존재하고, 이 중요도가 높은 순으로 인쇄를 진행하는 기능을 추가하자.
* 그리고 문제에서 주어지는 n번 문서가 몇 번째로 인쇄되는지 출력하라.

## 로직
1. 실제로 큐를 생성하고 push pop 하기보다는, 데이터가 저장된 list를 가지고 index를 통해 계산하는 방식으로 해결.
2. heapq를 통해 입력받은 중요도를 정렬함. 앞에 -를 붙여줘서 최대 힙으로 정렬. 이러면 -9 -8 -7 ... 이렇게 나오는데, pop 할 때 앞에 -를 다시 붙여주면 내림차순으로 뽑을 수 있음.
3. index를 0부터 시작해서 n까지 이동. 이동하며 해당 위치에 있는 데이터의 중요도를 파악하고 중요도가 높은 순서대로 제거 처리.
4. index >= list가 된다면 index값에 리스트의 길이를 빼준다. 이러면 다시 0 부터 시작 가능.
5. 문제에서 요구하는 문서가 제거 처리되면 반복문 종료하고 계산된 순서를 출력.

## 코드

```python
# https://www.acmicpc.net/problem/1966
import sys
import heapq

input = sys.stdin.readline

num = int(input())

# num = 테스트케이스 수.
for _ in range(num):

    # 문서의 개수, 몇 번째로 뽑히는지 확인하려는 타겟 문서의 번호
    size, target = map(int, input().split())

    # 각 문서의 중요도 리스트
    priority_list = list(map(int, input().split()))
    pq = []

    # 문서 제거 여부를 체크하기 위한 리스트
    visited = [False] * len(priority_list)

    # 문서 숫자만큼 반복해서 중요도를 내림차순 정렬.
    for i in range(size):
        heapq.heappush(pq, -priority_list[i])

    index = 0
    # 문서 제거 수
    count = 0
    max_number = -heapq.heappop(pq)
    while True:

        # index 위치의 문서의 중요도와 현재 가장 높은 중요도 비교
        if priority_list[index] == max_number:
            # 가장 높은 중요도의 문서라면 문서 제거 처리
            visited[index] = True
            count += 1
            if len(pq) != 0:
                # 남아있는 문서 중 가장 높은 중요도 저장
                max_number = -heapq.heappop(pq)
            else:
                break
        
        # index 값 변경. 이미 제거 처리 된 문서의 경우 index를 다시 +1 해줘야 한다.
        while True:
            index += 1
            if index >= size:
                index -= size
            if not visited[index]:
                break

        # 문제에서 요구한 문서가 제거 되었다면 계산 종료.
        if visited[target]:
            break
    
    print(count)

```
