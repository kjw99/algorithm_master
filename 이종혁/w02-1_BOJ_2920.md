# 오늘의 알고리즘 (2026.01.26)

## 오늘 푼 문제
- **백준 2920번**: [음계](https://www.acmicpc.net/problem/2920) (Bronze 2)

---

## 내 풀이

```python
# [[https://www.acmicpc.net/problem/2920](https://www.acmicpc.net/problem/2920)]
# [핵심 로직]
# 1. 숫자가 공백으로 들어오니까 map과 split으로 받아서 정수 리스트로 만든다.
# 2. 비교용 오름차순(1~8), 내림차순(8~1) 리스트를 미리 준비한다.
# 3. 입력받은 리스트가 준비한 리스트 중 어떤 것과 같은지 체크한다.

# 사용자 입력 처리
lst = list(map(int, input().split()))

# 비교 기준 정답지 생성
ascending_list = list(range(1, 9))      # [1, 2, 3, 4, 5, 6, 7, 8]
descending_list = list(range(8, 0, -1)) # [8, 7, 6, 5, 4, 3, 2, 1]

# 조건 비교 후 출력
if lst == ascending_list:
    print('ascending')
elif lst == descending_list:
    print('descending')
else:
    print('mixed')
```

## 문제설명
- 1부터 8까지 숫자가 주어졌을 때 오름차순인지, 내림차순인지, 아니면 뒤섞여 있는지(`mixed`) 구분하는 문제.

## 문제풀이
- **사고의 전환**: 처음에는 리스트를 돌면서 이전 숫자랑 비교하는 로직을 생각했는데, 숫자가 8개로 고정되어 있어서 그냥 정답 리스트를 미리 만들어두고 `==`로 통째로 비교하는 게 훨씬 직관적이고 편하다는 걸 깨달음.
- **도구의 발견**: `range(8, 0, -1)`을 써서 역순 리스트를 한 번에 만드는 법을 적용함. 끝점인 0은 포함되지 않으니까 1까지 딱 맞게 만들어짐.
- **출력 처리**: 파이썬은 리스트 요소의 값과 순서가 모두 같아야 `==`가 `True`가 되니까 별도의 루프 없이 조건문만으로 해결함.

## 배운점
### 1. range()의 방향성
- `range(1, 9, -1)`처럼 시작은 작은데 뒤로 가라고 하면 빈 리스트(`[]`)가 나온다는 걸 확인함. 역순은 무조건 시작값이 더 커야 함.
### 2. 리스트 비교 메커니즘
- 리스트 전체를 한 번에 비교하는 게 효율적이라는 걸 배움. 데이터가 고정된 패턴을 찾을 때는 이 방식이 베스트인 듯.

## 실무 관점의 참견
- 실무에서 `list`라는 이름을 변수로 써버리면 나중에 리스트 형변환 할 때 `list()` 함수를 못 쓰게 되는 대참사(Shadowing)가 발생할 수 있음. 변수명 지을 때 예약어 피하는 습관은 필수임.

## 덧붙임 (Self Feedback)
- 기초 문제지만 `range` 끝값 설정에서 0인지 1인지 헷갈렸음. 이런 기본적인 부분에서 실수 안 하도록 손에 더 익혀야겠다.
- 코드가 짧아질수록 가독성이 좋아지는 걸 보니 파이썬 내장 기능을 더 많이 공부해야겠다고 느낌.