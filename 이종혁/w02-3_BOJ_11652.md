# 오늘의 알고리즘 (2026-02-01)

## 2. 문제 정보
- 번호: 11652
- 제목: 카드
- 문제: 준규가 가지고 있는 N장의 카드에 적힌 정수가 주어졌을 때, 가장 많이 가지고 있는 정수를 구하는 프로그램. 가장 많이 가지고 있는 정수가 여러 가지라면, 작은 것을 출력한다.
- 링크: https://www.acmicpc.net/problem/11652
- 난이도: 실버 4

## 3. 내 풀이
```python
import sys

# 빠른 입력을 위해 sys.stdin.readline 사용
n = int(sys.stdin.readline())
card_counts = {}

# n번 반복하며 카드 숫자를 입력받아 딕셔너리에 저장
for _ in range(n):
    card = int(sys.stdin.readline())
    if card in card_counts:
        card_counts[card] += 1
    else:
        card_counts[card] = 1

# 최댓값과 정답을 찾기 위한 초기 설정
max_count = 0
answer = 0

# 딕셔너리 아이템을 순회하며 조건에 맞는 카드 찾기
for card, count in card_counts.items():
    if count > max_count:
        max_count = count
        answer = card
    elif count == max_count:
        # 개수가 같다면 더 작은 숫자를 선택
        if card < answer:
            answer = card

print(answer)
```

## 4. 항목별 설명
- 문제 풀이:
    리스트 정렬보다 효율적인 Dictionary(Hash Map)를 선택함. 카드 숫자가 매우 크지만 파이썬 int가 알아서 처리해주니 편했음. 루프를 돌면서 최댓값을 갱신할 때 동점자 조건(더 작은 숫자 선택)을 빼먹지 않도록 주의함.
- 배운 점:
    - sys.stdin.readline이 왜 빠른지, 시스템 레벨에서 데이터를 어떻게 긁어오는지 이해함.
    - 빈 딕셔너리에 무작정 인덱스로 접근하면 KeyError가 난다는 걸 경험함. 초기값 설정의 중요성을 다시 느낌.
    - .items()를 써서 키와