# 오늘의 알고리즘 (2026.01.24)

## 오늘 푼 문제
- **백준 10809번**: [알파벳 찾기](https://www.acmicpc.net/problem/10809) (Bronze 2)

---

## 내 풀이

```python
# [https://www.acmicpc.net/problem/10809]
# [핵심 로직]
# 1. 알파벳 a(97)부터 z(122)까지 아스키코드 범위를 순회한다.
# 2. 각 숫자를 chr()로 변환해 실제 알파벳 문자로 만든다.
# 3. 문자열의 find() 메소드를 이용해 처음 등장하는 위치를 찾는다.

s = input()

# a부터 z까지 아스키코드 숫자로 반복문 돌리기
for i in range(97, 123):
    # 숫자를 문자로 변환 (97 -> 'a')
    x = chr(i)
    
    # s에서 x라는 문자가 처음 나오는 위치 찾기
    # find는 문자가 없으면 자동으로 -1을 반환해줘서 개꿀임
    result = s.find(x)
    
    # 결과를 한 줄로 출력하기 위해 end=' ' 사용
    print(result, end=' ')
```

## 문제설명
- 알파벳 소문자로 된 단어 S가 주어지면, 각각의 알파벳(a~z)이 단어에 처음 등장하는 위치를 출력하는 문제.
- 만약 단어에 해당 알파벳이 없으면 `-1`을 출력해야 함.

## 문제풀이
- **사고의 전환**: 처음에는 'a, b, c, d...' 이걸 리스트로 다 타이핑해야 하나 고민했는데, 아스키코드를 활용하면 `range(97, 123)`으로 한 번에 돌릴 수 있다는 걸 알게 됨.
- **도구의 발견**: `find()` 함수가 "처음 발견된 인덱스"를 반환하고, "없으면 -1"을 준다는 특징이 이 문제 조건이랑 100% 일치해서 로직이 엄청 단순해짐.
- **출력 처리**: 결과값들이 한 줄로 나와야 해서 `print`의 `end` 옵션을 활용해 공백으로 구분함.

## 배운점
### 1. 아스키코드와 chr() 함수
- `chr(97)`이 'a'가 된다는 걸 확실히 익힘. 반복문에서 알파벳 순서대로 돌릴 때 하나하나 타이핑하는 것보다 훨씬 스마트하고 오타 걱정도 없는 방식인 듯.

### 2. find() vs index() 차이점
- 둘 다 위치를 찾는 건 같지만, `find()`는 찾는 게 없으면 `-1`을 뱉고 `index()`는 에러를 낸다는 차이를 알게 됨. 이번 문제처럼 "없으면 -1"인 상황에선 `find()`가 압도적으로 편함.

### 3. 실무 관점의 참견 (문자열 인코딩과 검색)
- 이런 식으로 문자를 숫자로 매칭하는 게 데이터 처리의 기본인 '인코딩'의 기초라는 걸 느낌. 대량의 데이터를 다룰 땐 매번 `find()`를 쓰면 느려질 수 있으니 상황에 맞는 최적화 방안도 나중에 고민해봐야겠음.

## 덧붙임 (Self Feedback)
- 처음에는 하나씩 다 적으려던 노가다(?)를 아스키코드 숫자로 변환해서 처리한 게 이번 풀이의 신의 한 수였던 것 같다. 역시 아는 만큼 코드가 짧아지고 편해진다. 
- 파이썬 내장 함수의 역할(반환값 등)을 정확히 알고 있으면 굳이 복잡하게 조건문 안 써도 깔끔하게 풀린다는 걸 다시 느낌.